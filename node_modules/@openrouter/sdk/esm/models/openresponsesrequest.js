/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v4";
import { remap as remap$ } from "../lib/primitives.js";
import * as openEnums from "../types/enums.js";
import { DataCollection$outboundSchema, } from "./datacollection.js";
import { OpenAIResponsesIncludable$outboundSchema, } from "./openairesponsesincludable.js";
import { OpenAIResponsesPrompt$outboundSchema, } from "./openairesponsesprompt.js";
import { OpenAIResponsesToolChoiceUnion$outboundSchema, } from "./openairesponsestoolchoiceunion.js";
import { OpenResponsesInput$outboundSchema, } from "./openresponsesinput.js";
import { OpenResponsesReasoningConfig$outboundSchema, } from "./openresponsesreasoningconfig.js";
import { OpenResponsesResponseText$outboundSchema, } from "./openresponsesresponsetext.js";
import { OpenResponsesWebSearch20250826Tool$outboundSchema, } from "./openresponseswebsearch20250826tool.js";
import { OpenResponsesWebSearchPreview20250311Tool$outboundSchema, } from "./openresponseswebsearchpreview20250311tool.js";
import { OpenResponsesWebSearchPreviewTool$outboundSchema, } from "./openresponseswebsearchpreviewtool.js";
import { OpenResponsesWebSearchTool$outboundSchema, } from "./openresponseswebsearchtool.js";
import { ProviderName$outboundSchema } from "./providername.js";
import { ProviderSort$outboundSchema } from "./providersort.js";
import { Quantization$outboundSchema } from "./quantization.js";
export const ServiceTier = {
    Auto: "auto",
};
export const Truncation = {
    Auto: "auto",
    Disabled: "disabled",
};
export const OpenResponsesRequestPdfEngine = {
    MistralOcr: "mistral-ocr",
    PdfText: "pdf-text",
    Native: "native",
};
export const OpenResponsesRequestEngine = {
    Native: "native",
    Exa: "exa",
};
/**
 * Routing strategy for multiple models: "fallback" (default) uses secondary models as backups, "sort" sorts all endpoints together by routing criteria.
 */
export const OpenResponsesRequestRoute = {
    Fallback: "fallback",
    Sort: "sort",
};
/** @internal */
export const OpenResponsesRequestToolFunction$outboundSchema = z.object({
    type: z.literal("function"),
    name: z.string(),
    description: z.nullable(z.string()).optional(),
    strict: z.nullable(z.boolean()).optional(),
    parameters: z.nullable(z.record(z.string(), z.nullable(z.any()))),
});
export function openResponsesRequestToolFunctionToJSON(openResponsesRequestToolFunction) {
    return JSON.stringify(OpenResponsesRequestToolFunction$outboundSchema.parse(openResponsesRequestToolFunction));
}
/** @internal */
export const OpenResponsesRequestToolUnion$outboundSchema = z.union([
    z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
    OpenResponsesWebSearchPreviewTool$outboundSchema,
    OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
    OpenResponsesWebSearchTool$outboundSchema,
    OpenResponsesWebSearch20250826Tool$outboundSchema,
]);
export function openResponsesRequestToolUnionToJSON(openResponsesRequestToolUnion) {
    return JSON.stringify(OpenResponsesRequestToolUnion$outboundSchema.parse(openResponsesRequestToolUnion));
}
/** @internal */
export const ServiceTier$outboundSchema = z.enum(ServiceTier);
/** @internal */
export const Truncation$outboundSchema = openEnums.outboundSchema(Truncation);
/** @internal */
export const Order$outboundSchema = z.union([
    ProviderName$outboundSchema,
    z.string(),
]);
export function orderToJSON(order) {
    return JSON.stringify(Order$outboundSchema.parse(order));
}
/** @internal */
export const Only$outboundSchema = z.union([
    ProviderName$outboundSchema,
    z.string(),
]);
export function onlyToJSON(only) {
    return JSON.stringify(Only$outboundSchema.parse(only));
}
/** @internal */
export const Ignore$outboundSchema = z
    .union([ProviderName$outboundSchema, z.string()]);
export function ignoreToJSON(ignore) {
    return JSON.stringify(Ignore$outboundSchema.parse(ignore));
}
/** @internal */
export const OpenResponsesRequestMaxPrice$outboundSchema = z.object({
    prompt: z.string().optional(),
    completion: z.string().optional(),
    image: z.string().optional(),
    audio: z.string().optional(),
    request: z.string().optional(),
});
export function openResponsesRequestMaxPriceToJSON(openResponsesRequestMaxPrice) {
    return JSON.stringify(OpenResponsesRequestMaxPrice$outboundSchema.parse(openResponsesRequestMaxPrice));
}
/** @internal */
export const OpenResponsesRequestProvider$outboundSchema = z.object({
    allowFallbacks: z.nullable(z.boolean()).optional(),
    requireParameters: z.nullable(z.boolean()).optional(),
    dataCollection: z.nullable(DataCollection$outboundSchema).optional(),
    zdr: z.nullable(z.boolean()).optional(),
    enforceDistillableText: z.nullable(z.boolean()).optional(),
    order: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
        .optional(),
    only: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()])))
        .optional(),
    ignore: z.nullable(z.array(z.union([ProviderName$outboundSchema, z.string()]))).optional(),
    quantizations: z.nullable(z.array(Quantization$outboundSchema)).optional(),
    sort: z.nullable(ProviderSort$outboundSchema).optional(),
    maxPrice: z.lazy(() => OpenResponsesRequestMaxPrice$outboundSchema)
        .optional(),
    minThroughput: z.nullable(z.number()).optional(),
    maxLatency: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        allowFallbacks: "allow_fallbacks",
        requireParameters: "require_parameters",
        dataCollection: "data_collection",
        enforceDistillableText: "enforce_distillable_text",
        maxPrice: "max_price",
        minThroughput: "min_throughput",
        maxLatency: "max_latency",
    });
});
export function openResponsesRequestProviderToJSON(openResponsesRequestProvider) {
    return JSON.stringify(OpenResponsesRequestProvider$outboundSchema.parse(openResponsesRequestProvider));
}
/** @internal */
export const OpenResponsesRequestPluginResponseHealing$outboundSchema = z.object({
    id: z.literal("response-healing"),
    enabled: z.boolean().optional(),
});
export function openResponsesRequestPluginResponseHealingToJSON(openResponsesRequestPluginResponseHealing) {
    return JSON.stringify(OpenResponsesRequestPluginResponseHealing$outboundSchema.parse(openResponsesRequestPluginResponseHealing));
}
/** @internal */
export const OpenResponsesRequestPdfEngine$outboundSchema = openEnums.outboundSchema(OpenResponsesRequestPdfEngine);
/** @internal */
export const OpenResponsesRequestPdf$outboundSchema = z.object({
    engine: OpenResponsesRequestPdfEngine$outboundSchema.optional(),
});
export function openResponsesRequestPdfToJSON(openResponsesRequestPdf) {
    return JSON.stringify(OpenResponsesRequestPdf$outboundSchema.parse(openResponsesRequestPdf));
}
/** @internal */
export const OpenResponsesRequestPluginFileParser$outboundSchema = z.object({
    id: z.literal("file-parser"),
    enabled: z.boolean().optional(),
    maxFiles: z.number().optional(),
    pdf: z.lazy(() => OpenResponsesRequestPdf$outboundSchema).optional(),
}).transform((v) => {
    return remap$(v, {
        maxFiles: "max_files",
    });
});
export function openResponsesRequestPluginFileParserToJSON(openResponsesRequestPluginFileParser) {
    return JSON.stringify(OpenResponsesRequestPluginFileParser$outboundSchema.parse(openResponsesRequestPluginFileParser));
}
/** @internal */
export const OpenResponsesRequestEngine$outboundSchema = openEnums.outboundSchema(OpenResponsesRequestEngine);
/** @internal */
export const OpenResponsesRequestPluginWeb$outboundSchema = z.object({
    id: z.literal("web"),
    enabled: z.boolean().optional(),
    maxResults: z.number().optional(),
    searchPrompt: z.string().optional(),
    engine: OpenResponsesRequestEngine$outboundSchema.optional(),
}).transform((v) => {
    return remap$(v, {
        maxResults: "max_results",
        searchPrompt: "search_prompt",
    });
});
export function openResponsesRequestPluginWebToJSON(openResponsesRequestPluginWeb) {
    return JSON.stringify(OpenResponsesRequestPluginWeb$outboundSchema.parse(openResponsesRequestPluginWeb));
}
/** @internal */
export const OpenResponsesRequestPluginModeration$outboundSchema = z.object({
    id: z.literal("moderation"),
});
export function openResponsesRequestPluginModerationToJSON(openResponsesRequestPluginModeration) {
    return JSON.stringify(OpenResponsesRequestPluginModeration$outboundSchema.parse(openResponsesRequestPluginModeration));
}
/** @internal */
export const OpenResponsesRequestPluginUnion$outboundSchema = z.union([
    z.lazy(() => OpenResponsesRequestPluginModeration$outboundSchema),
    z.lazy(() => OpenResponsesRequestPluginWeb$outboundSchema),
    z.lazy(() => OpenResponsesRequestPluginFileParser$outboundSchema),
    z.lazy(() => OpenResponsesRequestPluginResponseHealing$outboundSchema),
]);
export function openResponsesRequestPluginUnionToJSON(openResponsesRequestPluginUnion) {
    return JSON.stringify(OpenResponsesRequestPluginUnion$outboundSchema.parse(openResponsesRequestPluginUnion));
}
/** @internal */
export const OpenResponsesRequestRoute$outboundSchema = openEnums.outboundSchema(OpenResponsesRequestRoute);
/** @internal */
export const OpenResponsesRequest$outboundSchema = z.object({
    input: OpenResponsesInput$outboundSchema.optional(),
    instructions: z.nullable(z.string()).optional(),
    metadata: z.nullable(z.record(z.string(), z.string())).optional(),
    tools: z.array(z.union([
        z.lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
        OpenResponsesWebSearchPreviewTool$outboundSchema,
        OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
        OpenResponsesWebSearchTool$outboundSchema,
        OpenResponsesWebSearch20250826Tool$outboundSchema,
    ])).optional(),
    toolChoice: OpenAIResponsesToolChoiceUnion$outboundSchema.optional(),
    parallelToolCalls: z.nullable(z.boolean()).optional(),
    model: z.string().optional(),
    models: z.array(z.string()).optional(),
    text: OpenResponsesResponseText$outboundSchema.optional(),
    reasoning: z.nullable(OpenResponsesReasoningConfig$outboundSchema).optional(),
    maxOutputTokens: z.nullable(z.number()).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.number().optional(),
    promptCacheKey: z.nullable(z.string()).optional(),
    previousResponseId: z.nullable(z.string()).optional(),
    prompt: z.nullable(OpenAIResponsesPrompt$outboundSchema).optional(),
    include: z.nullable(z.array(OpenAIResponsesIncludable$outboundSchema))
        .optional(),
    background: z.nullable(z.boolean()).optional(),
    safetyIdentifier: z.nullable(z.string()).optional(),
    store: z.literal(false).default(false),
    serviceTier: ServiceTier$outboundSchema.default("auto"),
    truncation: z.nullable(Truncation$outboundSchema).optional(),
    stream: z.boolean().default(false),
    provider: z.nullable(z.lazy(() => OpenResponsesRequestProvider$outboundSchema)).optional(),
    plugins: z.array(z.union([
        z.lazy(() => OpenResponsesRequestPluginModeration$outboundSchema),
        z.lazy(() => OpenResponsesRequestPluginWeb$outboundSchema),
        z.lazy(() => OpenResponsesRequestPluginFileParser$outboundSchema),
        z.lazy(() => OpenResponsesRequestPluginResponseHealing$outboundSchema),
    ])).optional(),
    route: z.nullable(OpenResponsesRequestRoute$outboundSchema).optional(),
    user: z.string().optional(),
    sessionId: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        toolChoice: "tool_choice",
        parallelToolCalls: "parallel_tool_calls",
        maxOutputTokens: "max_output_tokens",
        topP: "top_p",
        topK: "top_k",
        promptCacheKey: "prompt_cache_key",
        previousResponseId: "previous_response_id",
        safetyIdentifier: "safety_identifier",
        serviceTier: "service_tier",
        sessionId: "session_id",
    });
});
export function openResponsesRequestToJSON(openResponsesRequest) {
    return JSON.stringify(OpenResponsesRequest$outboundSchema.parse(openResponsesRequest));
}
//# sourceMappingURL=openresponsesrequest.js.map